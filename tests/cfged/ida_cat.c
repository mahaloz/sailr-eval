/* This file was generated by the Hex-Rays decompiler version 8.0.0.220729.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

bool  is_ENOTSUP(int err);
void  next_line_num();
void  emit_stdin_note();
void  write_pending(char *outbuf, char **bpout);
int  copy_cat();
bool  simple_cat(char *buf, idx_t bufsize);
bool  cat(char *inbuf, idx_t insize, char *outbuf, idx_t outsize, bool show_nonprinting, bool show_tabs, bool number, bool number_nonblank, bool show_ends, bool squeeze_blank);
void emit_ancillary_info(const char *program); // idb
idx_t  io_blksize(long a1);
void  usage(int status);
int  main(int argc, const char **argv, const char **envp);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// int fputs_unlocked(const char *s, FILE *stream);
// long  full_write(_QWORD, _QWORD, _QWORD); weak
// int *_errno_location(void);
// void error(int status, int errnum, const char *format, ...);
// long  copy_file_range(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD); weak
// long  safe_read(_QWORD, _QWORD, _QWORD); weak
// char *stpcpy(char *dest, const char *src);
// void *memmove(void *dest, const void *src, size_t n);
// int ioctl(int fd, unsigned long request, ...);
// long  quotearg_style(_QWORD, _QWORD); weak
// int strcmp(const char *s1, const char *s2);
// long  _printf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// char *setlocale(int category, const char *locale);
// int strncmp(const char *s1, const char *s2, size_t n);
// long  _fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void  exit(int status);
// long  set_program_name(_QWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// char *textdomain(const char *domainname);
// int atexit(void (*func)(void));
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// long  version_etc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int fstat(int fd, struct stat *buf);
// int getpagesize(void);
// int open(const char *file, int oflag, ...);
// long  fdadvise(_QWORD, _QWORD, _QWORD); weak
// long  xalignalloc(_QWORD, _QWORD); weak
// long  alignfree(_QWORD); weak
// int close(int fd);
// __off_t lseek(int fd, __off_t offset, int whence);
// long  xalloc_die(_QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

char line_buf[20] = "                 0\t"; // idb
bool pending_cr; // idb
int newlines2; // idb
int input_desc; // idb
const char *infile; // idb
const char LC6 = '\0'; // idb
const char LC36[] = "-"; // idb
const option long_options_0[10] =
{
  { "number-nonblank", 0, &is_ENOTSUP, 98 },
  { "number", 0, &is_ENOTSUP, 110 },
  { "squeeze-blank", 0, &is_ENOTSUP, 115 },
  { "show-nonprinting", 0, &is_ENOTSUP, 118 },
  { "show-ends", 0, &is_ENOTSUP, 69 },
  { "show-tabs", 0, &is_ENOTSUP, 84 },
  { "show-all", 0, &is_ENOTSUP, 65 },
  { "help", 0, &is_ENOTSUP, -130 },
  { "version", 0, &is_ENOTSUP, -131 },
  { &is_ENOTSUP, 0, &is_ENOTSUP, 0 }
}; // idb
char *line_num_start = (char *)0xCA1LL; // idb
char *line_num_print = (char *)0xC9CLL; // idb
// extern struct _IO_FILE *stdout;
// extern _UNKNOWN program_name; weak
// extern struct _IO_FILE *stderr;
// extern void (*close_stdout)(void); weak
// extern _UNKNOWN Version; weak
// extern int optind;


//----- (0000000000000000) ----------------------------------------------------
bool  is_ENOTSUP(int err)
{
  return err == 95;
}

//----- (0000000000000010) ----------------------------------------------------
void  next_line_num()
{
  char *v0; // rcx
  char *v1; // rax
  unsigned long v2; // rdx

  v0 = line_num_start;
  v1 = &line_buf[17];
  do
  {
    if ( *v1 <= 56 )
    {
      ++*v1;
      return;
    }
    *v1-- = 48;
  }
  while ( v0 <= v1 );
  if ( v0 <= line_buf )
  {
    line_buf[0] = 62;
    v2 = (unsigned long)v0;
  }
  else
  {
    v2 = (unsigned long)(v0 - 1);
    *(v0 - 1) = 49;
    line_num_start = v0 - 1;
  }
  if ( (unsigned long)line_num_print > v2 )
    --line_num_print;
}

//----- (0000000000000090) ----------------------------------------------------
void  emit_stdin_note()
{
  struct _IO_FILE *v0; // rbp
  char *v1; // rax

  v0 = stdout;
  v1 = dcgettext(0LL, "\nWith no FILE, or when FILE is -, read standard input.\n", 5);
  fputs_unlocked(v1, v0);
}

//----- (00000000000000C0) ----------------------------------------------------
void  write_pending(char *outbuf, char **bpout)
{
  signed long v2; // rbp
  char *v3; // r12
  int *v4; // rax

  if ( *bpout - outbuf > 0 )
  {
    v2 = *bpout - outbuf;
    if ( v2 != full_write(1LL, outbuf, v2) )
    {
      v3 = dcgettext(0LL, "write error", 5);
      v4 = _errno_location();
      error(1, *v4, v3);
      JUMPOUT(0x128LL);
    }
    *bpout = outbuf;
  }
}
// 123: control flows out of bounds to 128
// 1DF8: using guessed type long  full_write(_QWORD, _QWORD, _QWORD);

//----- (0000000000000130) ----------------------------------------------------
int  copy_cat()
{
  unsigned char i; // bl
  long v1; // rax
  int v2; // r8d
  int *v4; // rax
  int *v5; // rbx
  unsigned long v6; // rdx
  long v7; // rax
  const char *v8; // rax

  for ( i = 0; ; i = 1 )
  {
    v1 = copy_file_range((unsigned int)input_desc, 0LL, 1LL, 0LL, 0x7FFFFFFFC0000000LL, 0LL);
    if ( v1 == -1 )
      break;
    if ( !v1 )
      return i;
  }
  v4 = _errno_location();
  v2 = 0;
  v5 = v4;
  if ( *v4 == 38 )
    return v2;
  if ( is_ENOTSUP(*v4) )
    return v2;
  if ( (unsigned int)v6 <= 0x1A )
  {
    v7 = 71565826LL;
    if ( _bittest64(&v7, v6) )
      return v2;
  }
  v8 = (const char *)quotearg_n_style_colon(0LL, 3LL, infile);
  error(0, *v5, "%s", v8);
  return -1;
}
// 163: variable 'v2' is possibly undefined
// 1A0: variable 'v6' is possibly undefined
// 1E10: using guessed type long  copy_file_range(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1E18: using guessed type long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD);

//----- (00000000000001E0) ----------------------------------------------------
bool  simple_cat(char *buf, idx_t bufsize)
{
  long v2; // rax
  const char *v3; // r12
  int *v4; // rax
  char *v6; // r12
  int *v7; // rax

  while ( 1 )
  {
    v2 = safe_read((unsigned int)input_desc, buf, bufsize);
    if ( v2 == -1 )
    {
      v3 = (const char *)quotearg_n_style_colon(0LL, 3LL, infile);
      v4 = _errno_location();
      error(0, *v4, "%s", v3);
      return 0;
    }
    if ( !v2 )
      break;
    if ( full_write(1LL, buf, v2) != v2 )
    {
      v6 = dcgettext(0LL, "write error", 5);
      v7 = _errno_location();
      error(1, *v7, v6);
      JUMPOUT(0x296LL);
    }
  }
  return 1;
}
// 291: control flows out of bounds to 296
// 1DF8: using guessed type long  full_write(_QWORD, _QWORD, _QWORD);
// 1E18: using guessed type long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD);
// 1E20: using guessed type long  safe_read(_QWORD, _QWORD, _QWORD);

//----- (00000000000002A0) ----------------------------------------------------
bool  cat(
        char *inbuf,
        idx_t insize,
        char *outbuf,
        idx_t outsize,
        bool show_nonprinting,
        bool show_tabs,
        bool number,
        bool number_nonblank,
        bool show_ends,
        bool squeeze_blank)
{
  char *v10; // r15
  char *v11; // r13
  unsigned int v15; // r13d
  long v16; // rax
  char *v17; // rax
  char v18; // r14
  char *v19; // rax
  bool i; // dl
  char *v21; // rdx
  char *v22; // rdi
  char *v23; // rax
  char *v24; // rax
  bool v25; // di
  bool v26; // si
  char *v27; // rdx
  bool v28; // al
  char *v29; // r14
  int *v30; // r8
  unsigned long v31; // rax
  long v32; // rcx
  long v33; // r12
  char *v34; // rax
  const char *v36; // r12
  int *v37; // rax
  char *v38; // r12
  int *v39; // rax
  int newlines; // [rsp+Ch] [rbp-9Ch]
  char *eob; // [rsp+10h] [rbp-98h]
  int *eoba; // [rsp+10h] [rbp-98h]
  char *v43; // [rsp+18h] [rbp-90h]
  char *v47; // [rsp+40h] [rbp-68h]
  char use_fionread; // [rsp+4Ch] [rbp-5Ch]
  int n_to_read; // [rsp+5Ch] [rbp-4Ch] BYREF
  char *bpout[9]; // [rsp+60h] [rbp-48h] BYREF

  v10 = inbuf + 1;
  v11 = outbuf;
  bpout[1] = (char *)__readfsqword(0x28u);
  v47 = inbuf + 1;
  bpout[0] = outbuf;
  eob = inbuf;
  use_fionread = 1;
  newlines = newlines2;
  v43 = &outbuf[outsize];
  while ( 2 )
  {
    if ( v43 <= v11 )
      goto LABEL_60;
LABEL_3:
    if ( eob >= v10 )
    {
      ++newlines;
      v21 = v10 + 1;
      v22 = bpout[0];
      if ( newlines > 0 )
      {
        if ( newlines != 1 )
        {
          newlines = 2;
          if ( squeeze_blank )
          {
            v18 = *v10;
            v11 = bpout[0];
            ++v10;
            goto LABEL_10;
          }
        }
        if ( !number_nonblank && number )
        {
          next_line_num();
          v23 = stpcpy(v22, line_num_print);
          v21 = v10 + 1;
          v22 = v23;
        }
      }
      if ( show_ends )
      {
        v24 = v22;
        if ( pending_cr )
        {
          pending_cr = 0;
          v24 = v22 + 2;
          *(_WORD *)v22 = 19806;
        }
        *v24 = 36;
        v22 = v24 + 1;
      }
      v11 = v22 + 1;
      v17 = v10;
      *v22 = 10;
      v10 = v21;
      bpout[0] = v22 + 1;
LABEL_9:
      v18 = *v17;
LABEL_10:
      if ( v18 == 10 )
        continue;
      if ( pending_cr )
      {
        pending_cr = 0;
        bpout[0] = v11 + 1;
        *v11++ = 13;
      }
      if ( newlines >= 0 && number )
      {
        next_line_num();
        bpout[0] = stpcpy(v11, line_num_print);
        v11 = bpout[0];
      }
      if ( show_nonprinting )
      {
        v19 = v11;
        for ( i = 0; ; i = show_nonprinting )
        {
          if ( (unsigned char)v18 > 0x1Fu )
          {
            if ( (unsigned char)v18 > 0x7Eu )
            {
              if ( v18 == 127 )
              {
                v19 += 2;
                *((_WORD *)v19 - 1) = 16222;
              }
              else
              {
                *(_WORD *)v19 = 11597;
                if ( (unsigned char)v18 <= 0x9Fu )
                {
                  v19[2] = 94;
                  v19 += 4;
                  *(v19 - 1) = v18 - 64;
                }
                else if ( v18 == -1 )
                {
                  v19 += 4;
                  *((_WORD *)v19 - 1) = 16222;
                }
                else
                {
                  v19 += 3;
                  *(v19 - 1) = v18 + 0x80;
                }
              }
            }
            else
            {
              *v19++ = v18;
            }
          }
          else if ( v18 == 9 && !show_tabs )
          {
            *v19++ = 9;
          }
          else
          {
            if ( v18 == 10 )
            {
              if ( i )
              {
                bpout[0] = v19;
                v11 = v19;
              }
              goto LABEL_59;
            }
            *v19 = 94;
            v19 += 2;
            *(v19 - 1) = v18 + 64;
          }
          v18 = *v10++;
        }
      }
      v25 = 0;
      v26 = 0;
      v27 = v11;
      while ( 1 )
      {
        if ( show_tabs && v18 == 9 )
        {
          v26 = show_tabs && v18 == 9;
          v27 += 2;
          *((_WORD *)v27 - 1) = 18782;
          v18 = *v10;
        }
        else
        {
          if ( v18 == 10 )
          {
            if ( v25 )
              pending_cr = 1;
            if ( v26 )
            {
              bpout[0] = v27;
              v11 = v27;
            }
LABEL_59:
            newlines = -1;
            if ( v43 <= v11 )
            {
LABEL_60:
              v29 = outbuf;
              do
              {
                if ( full_write(1LL, v29, outsize) != outsize )
                {
                  v38 = dcgettext(0LL, "write error", 5);
                  v39 = _errno_location();
                  error(1, *v39, v38);
                }
                v29 += outsize;
              }
              while ( outsize <= v11 - v29 );
              memmove(outbuf, v29, v11 - v29);
              bpout[0] = &outbuf[v11 - v29];
            }
            goto LABEL_3;
          }
          if ( v18 == 13 && (v28 = show_ends && *v10 == 10) )
          {
            if ( eob == v10 )
            {
              v25 = show_ends && *v10 == 10;
              v18 = 10;
            }
            else
            {
              v27 += 2;
              *((_WORD *)v27 - 1) = 19806;
              v26 = v28;
              v18 = *v10;
            }
          }
          else
          {
            *v27 = v18;
            v26 = 1;
            v18 = *v10;
            ++v27;
          }
        }
        ++v10;
      }
    }
    break;
  }
  n_to_read = 0;
  if ( !use_fionread )
    goto LABEL_5;
  v15 = input_desc;
  if ( ioctl(input_desc, 0x541BuLL, &n_to_read) < 0 )
  {
    v30 = _errno_location();
    v31 = (unsigned int)*v30;
    use_fionread = (_DWORD)v31 == 25 || (_DWORD)v31 == 95;
    if ( use_fionread )
    {
      use_fionread = 0;
    }
    else if ( (unsigned int)v31 > 0x26 || (v32 = 0x4000480000LL, !_bittest64(&v32, v31)) )
    {
      eoba = v30;
      v33 = quotearg_style(4LL, infile);
      v34 = dcgettext(0LL, "cannot do ioctl on %s", 5);
      error(0, *eoba, v34, v33);
      goto LABEL_73;
    }
  }
  if ( !n_to_read )
  {
LABEL_5:
    write_pending(outbuf, bpout);
    v15 = input_desc;
  }
  v16 = safe_read(v15, inbuf, insize);
  if ( v16 == -1 )
  {
    v36 = (const char *)quotearg_n_style_colon(0LL, 3LL, infile);
    v37 = _errno_location();
    error(0, *v37, "%s", v36);
    write_pending(outbuf, bpout);
    use_fionread = 0;
  }
  else
  {
    if ( v16 )
    {
      v11 = bpout[0];
      v10 = v47;
      eob = &inbuf[v16];
      inbuf[v16] = 10;
      v17 = inbuf;
      goto LABEL_9;
    }
    write_pending(outbuf, bpout);
    use_fionread = 1;
  }
LABEL_73:
  newlines2 = newlines;
  return use_fionread;
}
// 1DF8: using guessed type long  full_write(_QWORD, _QWORD, _QWORD);
// 1E18: using guessed type long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD);
// 1E20: using guessed type long  safe_read(_QWORD, _QWORD, _QWORD);
// 1E40: using guessed type long  quotearg_style(_QWORD, _QWORD);

//----- (0000000000000880) ----------------------------------------------------
void  emit_ancillary_info(const char *program)
{
  emit_ancillary_info::infomap *v1; // rbx
  const char *v2; // rsi
  const char *node; // r13
  char *v4; // rax
  char *v5; // rdi
  char *v6; // rax
  const char *v7; // r12
  char *v8; // rsi
  char *v9; // rax
  char *v10; // rdi
  struct _IO_FILE *v11; // rbp
  char *v12; // rax
  char *v13; // rax
  emit_ancillary_info::infomap infomap[7]; // [rsp+0h] [rbp-A8h] BYREF
  unsigned long v15; // [rsp+78h] [rbp-30h]

  v15 = __readfsqword(0x28u);
  infomap[3].program = "sha256sum";
  v1 = infomap;
  infomap[4].program = "sha384sum";
  infomap[5].program = "sha512sum";
  infomap[6].program = 0LL;
  infomap[6].node = 0LL;
  infomap[0].program = "[";
  infomap[0].node = "test invocation";
  infomap[1].program = "coreutils";
  infomap[1].node = "Multi-call invocation";
  infomap[2].program = "sha224sum";
  infomap[2].node = "sha2 utilities";
  infomap[3].node = "sha2 utilities";
  infomap[4].node = "sha2 utilities";
  infomap[5].node = "sha2 utilities";
  do
  {
    v2 = v1[1].program;
    ++v1;
  }
  while ( v2 && strcmp("cat", v2) );
  node = v1->node;
  if ( !node )
  {
    v9 = dcgettext(0LL, "\n%s online help: <%s>\n", 5);
    _printf_chk(1LL, v9, "GNU coreutils", "https://www.gnu.org/software/coreutils/");
    v10 = setlocale(5, 0LL);
    if ( !v10 || !strncmp(v10, "en_", 3uLL) )
    {
      v13 = dcgettext(0LL, "Full documentation <%s%s>\n", 5);
      node = "cat";
      _printf_chk(1LL, v13, "https://www.gnu.org/software/coreutils/", "cat");
      v7 = " invocation";
      goto LABEL_9;
    }
    node = "cat";
    goto LABEL_13;
  }
  v4 = dcgettext(0LL, "\n%s online help: <%s>\n", 5);
  _printf_chk(1LL, v4, "GNU coreutils", "https://www.gnu.org/software/coreutils/");
  v5 = setlocale(5, 0LL);
  if ( v5 && strncmp(v5, "en_", 3uLL) )
  {
LABEL_13:
    v11 = stdout;
    v12 = dcgettext(0LL, "Report any translation bugs to <https://translationproject.org/team/>\n", 5);
    fputs_unlocked(v12, v11);
  }
  v6 = dcgettext(0LL, "Full documentation <%s%s>\n", 5);
  _printf_chk(1LL, v6, "https://www.gnu.org/software/coreutils/", "cat");
  v7 = " invocation";
  if ( node != "cat" )
    v7 = &LC6;
LABEL_9:
  v8 = dcgettext(0LL, "or available locally via: info '(coreutils) %s%s'\n", 5);
  _printf_chk(1LL, v8, node, v7);
}
// 1E58: using guessed type long  _printf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000000B00) ----------------------------------------------------
idx_t  io_blksize(long a1)
{
  idx_t result; // rax

  result = 0x20000LL;
  if ( (unsigned long)(a1 - 0x20000) <= 0x1FFFFFFFFFFE0000LL )
    return a1;
  return result;
}

//----- (0000000000000B20) ----------------------------------------------------
void   usage(int status)
{
  long v1; // r12
  char *v2; // rax
  char *v3; // rax
  long v4; // rcx
  struct _IO_FILE *v5; // r12
  char *v6; // rax
  struct _IO_FILE *v7; // r12
  char *v8; // rax
  struct _IO_FILE *v9; // r12
  char *v10; // rax
  struct _IO_FILE *v11; // r12
  char *v12; // rax
  struct _IO_FILE *v13; // r12
  char *v14; // rax
  long v15; // r12
  char *v16; // rax

  v1 = program_name;
  if ( status )
  {
    v2 = dcgettext(0LL, "Try '%s --help' for more information.\n", 5);
    _fprintf_chk(stderr, 1LL, v2, v1);
  }
  else
  {
    v3 = dcgettext(0LL, "Usage: %s [OPTION]... [FILE]...\n", 5);
    _printf_chk(1LL, v3, v1, v4);
    v5 = stdout;
    v6 = dcgettext(0LL, "Concatenate FILE(s) to standard output.\n", 5);
    fputs_unlocked(v6, v5);
    emit_stdin_note();
    v7 = stdout;
    v8 = dcgettext(
           0LL,
           "\n"
           "  -A, --show-all           equivalent to -vET\n"
           "  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
           "  -e                       equivalent to -vE\n"
           "  -E, --show-ends          display $ at end of each line\n"
           "  -n, --number             number all output lines\n"
           "  -s, --squeeze-blank      suppress repeated empty output lines\n",
           5);
    fputs_unlocked(v8, v7);
    v9 = stdout;
    v10 = dcgettext(
            0LL,
            "  -t                       equivalent to -vT\n"
            "  -T, --show-tabs          display TAB characters as ^I\n"
            "  -u                       (ignored)\n"
            "  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n",
            5);
    fputs_unlocked(v10, v9);
    v11 = stdout;
    v12 = dcgettext(0LL, "      --help        display this help and exit\n", 5);
    fputs_unlocked(v12, v11);
    v13 = stdout;
    v14 = dcgettext(0LL, "      --version     output version information and exit\n", 5);
    fputs_unlocked(v14, v13);
    v15 = program_name;
    v16 = dcgettext(
            0LL,
            "\n"
            "Examples:\n"
            "  %s f - g  Output f's contents, then standard input, then g's contents.\n"
            "  %s        Copy standard input to standard output.\n",
            5);
    _printf_chk((char *)is_ENOTSUP + 1, v16, v15, v15);
    emit_ancillary_info((const char *)is_ENOTSUP + 1);
  }
  exit(status);
}
// B86: variable 'v4' is possibly undefined
// 1E58: using guessed type long  _printf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 1E80: using guessed type long  _fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000001320) ----------------------------------------------------
int  main(int argc, const char **argv, const char **envp)
{
  const char *v5; // rdi
  idx_t v6; // rbp
  int v7; // eax
  idx_t v8; // rax
  const char *v9; // r12
  const char *v10; // rdi
  int v11; // ebx
  unsigned int v12; // r15d
  long v13; // rsi
  char *v14; // r15
  bool v15; // of
  int v16; // ebx
  const char *v17; // r15
  int *v18; // rax
  const char *v20; // r15
  int *v21; // rax
  long v22; // r15
  char *v23; // rax
  char *v24; // r12
  int *v25; // rax
  int *v26; // rax
  int v27; // eax
  char *v28; // r12
  int *v29; // rax
  char show_nonprinting; // [rsp+Ch] [rbp-11Ch]
  idx_t outsize; // [rsp+10h] [rbp-118h]
  idx_t page_size; // [rsp+18h] [rbp-110h]
  char *outbuf; // [rsp+20h] [rbp-108h]
  char show_tabs; // [rsp+30h] [rbp-F8h]
  char ok; // [rsp+35h] [rbp-F3h]
  char squeeze_blank; // [rsp+36h] [rbp-F2h]
  char show_ends; // [rsp+37h] [rbp-F1h]
  int v38; // [rsp+38h] [rbp-F0h]
  char number; // [rsp+3Ch] [rbp-ECh]
  bool have_read_stdin; // [rsp+3Eh] [rbp-EAh]
  char number_nonblank; // [rsp+3Fh] [rbp-E9h]
  __dev_t st_dev; // [rsp+40h] [rbp-E8h]
  __ino_t st_ino; // [rsp+48h] [rbp-E0h]
  struct stat out_ino; // [rsp+50h] [rbp-D8h] BYREF
  unsigned long v45; // [rsp+E8h] [rbp-40h]

  v5 = *argv;
  v45 = __readfsqword(0x28u);
  set_program_name(v5);
  setlocale(6, &LC6);
  bindtextdomain("coreutils", "/usr/local/share/locale");
  v6 = (idx_t)"benstuvAET";
  textdomain("coreutils");
  atexit((void (*)(void))&close_stdout);
  show_tabs = 0;
  show_nonprinting = 0;
  show_ends = 0;
  squeeze_blank = 0;
  number_nonblank = 0;
  number = 0;
  while ( 2 )
  {
    v7 = getopt_long(argc, (char *const *)argv, "benstuvAET", long_options_0, 0LL);
    if ( v7 != -1 )
    {
      if ( v7 <= 118 )
      {
        if ( v7 > 64 )
        {
          switch ( v7 )
          {
            case 'A':
              show_tabs = 1;
              show_nonprinting = 1;
              show_ends = 1;
              continue;
            case 'E':
              goto LABEL_7;
            case 'T':
              show_tabs = 1;
              continue;
            case 'b':
              number_nonblank = 1;
              number = 1;
              continue;
            case 'e':
              show_nonprinting = 1;
LABEL_7:
              show_ends = 1;
              continue;
            case 'n':
              number = 1;
              continue;
            case 's':
              squeeze_blank = 1;
              continue;
            case 't':
              show_tabs = 1;
              show_nonprinting = 1;
              continue;
            case 'u':
              continue;
            case 'v':
              show_nonprinting = 1;
              continue;
            default:
              goto LABEL_59;
          }
        }
        if ( v7 == -131 )
        {
          version_etc(stdout, "cat", "GNU coreutils", Version, "Torbjorn Granlund", "Richard M. Stallman", 0LL);
          exit(0);
        }
        if ( v7 == -130 )
          usage(0);
      }
LABEL_59:
      usage(1);
    }
    break;
  }
  if ( fstat(1, &out_ino) < 0 )
  {
LABEL_61:
    v28 = dcgettext(0LL, "standard output", 5);
    v29 = _errno_location();
    error(1, *v29, v28);
  }
  v8 = io_blksize(out_ino.st_blksize);
  v9 = (const char *)optind;
  outsize = v8;
  infile = "-";
  st_dev = out_ino.st_dev;
  st_ino = out_ino.st_ino;
  v38 = out_ino.st_mode & 0xF000;
  ok = 1;
  v10 = "-";
  have_read_stdin = 0;
  page_size = getpagesize();
  if ( argc > (int)v9 )
    goto LABEL_34;
  v11 = (unsigned char)LC36[0] - 45;
  if ( LC36[0] == 45 )
    goto LABEL_35;
  while ( 1 )
  {
    input_desc = open(v10, 0);
    v12 = input_desc;
    if ( input_desc >= 0 )
      goto LABEL_22;
LABEL_38:
    ++v9;
    v17 = (const char *)quotearg_n_style_colon(0LL, 3LL, infile);
    v18 = _errno_location();
    error(0, *v18, "%s", v17);
    ok = 0;
    if ( argc <= (int)v9 )
      break;
LABEL_34:
    v10 = argv[(_QWORD)v9];
    v16 = *(unsigned char *)v10;
    infile = v10;
    v11 = v16 - 45;
    if ( !v11 )
    {
LABEL_35:
      v11 = *((unsigned char *)v10 + 1);
      if ( !v10[1] )
      {
        input_desc = 0;
        v12 = 0;
        have_read_stdin = 1;
LABEL_22:
        if ( fstat(v12, &out_ino) >= 0 )
        {
          v6 = io_blksize(out_ino.st_blksize);
          fdadvise(v12, 0LL, 0LL);
          if ( v38 == 0x8000
            && out_ino.st_dev == st_dev
            && out_ino.st_ino == st_ino
            && lseek(input_desc, 0LL, 1) < out_ino.st_size )
          {
            v22 = quotearg_n_style_colon(0LL, 3LL, infile);
            v23 = dcgettext(0LL, "%s: input file is output file", 5);
            error(0, 0, v23, v22);
            ok = 0;
            goto contin;
          }
          if ( (unsigned char)show_ends | (unsigned char)number
            || (unsigned char)show_tabs | (unsigned char)show_nonprinting
            || squeeze_blank )
          {
            v13 = 4 * v6;
            v14 = (char *)xalignalloc(page_size, v6 + 1);
            if ( !is_mul_ok(4uLL, v6)
              || (v15 = __OFADD__(outsize, v13), v13 += outsize, v15)
              || (v15 = __OFADD__(19LL, v13), v13 += 19LL, v15) )
            {
              xalloc_die(page_size, v13);
              goto LABEL_61;
            }
            outbuf = (char *)xalignalloc(page_size, v13);
            ok &= cat(
                    v14,
                    v6,
                    outbuf,
                    outsize,
                    show_nonprinting & 1,
                    show_tabs & 1,
                    number,
                    number_nonblank,
                    show_ends,
                    squeeze_blank);
            alignfree(outbuf);
            goto LABEL_31;
          }
          if ( v38 != 0x8000 || (out_ino.st_mode & 0xF000) != 0x8000 )
          {
LABEL_49:
            if ( outsize >= v6 )
              v6 = outsize;
            v14 = (char *)xalignalloc(page_size, v6);
            ok &= simple_cat(v14, v6);
            goto LABEL_31;
          }
          goto LABEL_57;
        }
        v20 = (const char *)quotearg_n_style_colon(0LL, 3LL, infile);
        v21 = _errno_location();
        error(0, *v21, "%s", v20);
        ok = 0;
        goto contin;
      }
    }
  }
LABEL_39:
  if ( pending_cr )
    goto LABEL_55;
  while ( have_read_stdin && close(0) < 0 )
  {
    v24 = dcgettext(0LL, "closing standard input", 5);
    v25 = _errno_location();
    error(1, *v25, v24);
LABEL_55:
    if ( full_write(1LL, "\r", 1LL) != 1 )
    {
      v9 = dcgettext(0LL, "write error", 5);
      v26 = _errno_location();
      error(1, *v26, v9);
LABEL_57:
      v27 = copy_cat();
      if ( !v27 )
        goto LABEL_49;
      v14 = 0LL;
      ok &= v27 > 0;
LABEL_31:
      alignfree(v14);
contin:
      if ( v11 && close(input_desc) < 0 )
        goto LABEL_38;
      if ( argc > (int)++v9 )
        goto LABEL_34;
      goto LABEL_39;
    }
  }
  return (unsigned char)ok ^ 1;
}
// 1DF8: using guessed type long  full_write(_QWORD, _QWORD, _QWORD);
// 1E18: using guessed type long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD);
// 1E90: using guessed type long  set_program_name(_QWORD);
// 1EA8: using guessed type void (*close_stdout)(void);
// 1EC8: using guessed type long  version_etc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1EF0: using guessed type long  fdadvise(_QWORD, _QWORD, _QWORD);
// 1EF8: using guessed type long  xalignalloc(_QWORD, _QWORD);
// 1F00: using guessed type long  alignfree(_QWORD);
// 1F18: using guessed type long  xalloc_die(_QWORD, _QWORD);

// nfuncs=45 queued=11 decompiled=11 lumina nreq=0 worse=0 better=0
// ALL OK, 11 function(s) have been successfully decompiled
