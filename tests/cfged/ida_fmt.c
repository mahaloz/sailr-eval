/* This file was generated by the Hex-Rays decompiler version 8.0.0.220729.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void  set_other_indent(bool same_paragraph);
bool  same_para(int c);
COST  base_cost(WORD *this);
COST  line_cost(WORD *next, int len);
void  fmt_paragraph();
void  emit_stdin_note();
void  emit_mandatory_arg_note();
void  set_prefix(char *p);
int  get_space(FILE *f, int c);
int  get_prefix(FILE *f);
void  put_space(int space);
void  put_word(WORD *w);
void  put_line(WORD *w, int indent);
void  put_paragraph(WORD *finish);
int  copy_rest(FILE *f, int c);
void  check_punctuation(WORD *w);
void  flush_paragraph();
int  get_line(FILE *f, int c);
bool  get_paragraph(FILE *f);
bool  fmt(FILE *f, const char *file);
void emit_ancillary_info(const char *program); // idb
void  usage(int status);
int  main(int argc, const char **argv, const char **envp);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// int fputs_unlocked(const char *s, FILE *stream);
// size_t strlen(const char *s);
// int getc_unlocked(FILE *stream);
// int putchar_unlocked(int c);
// char *strchr(const char *s, int c);
// const unsigned short **_ctype_b_loc(void);
// long  _memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// long  c_isspace(_QWORD); weak
// void  _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// long  fadvise(_QWORD, _QWORD); weak
// int ferror_unlocked(FILE *stream);
// long  rpl_fclose(_QWORD); weak
// long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD); weak
// void error(int status, int errnum, const char *format, ...);
// void clearerr_unlocked(FILE *stream);
// int *_errno_location(void);
// int strcmp(const char *s1, const char *s2);
// long  _printf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// char *setlocale(int category, const char *locale);
// int strncmp(const char *s1, const char *s2, size_t n);
// long  _fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void  exit(int status);
// long  set_program_name(_QWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// char *textdomain(const char *domainname);
// int atexit(void (*func)(void));
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// long  version_etc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// long  xdectoumax(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// long  quotearg_style(_QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

int last_line_length; // idb
int next_prefix_indent; // idb
int next_char; // idb
int other_indent; // idb
int first_indent; // idb
int prefix_indent; // idb
bool tabs; // idb
WORD *word_limit; // idb
WORD unused_word_type[1000]; // idb
char *wptr; // idb
char parabuf[5000]; // idb
int out_column; // idb
int in_column; // idb
int goal_width; // idb
int prefix_length; // idb
int prefix_lead_space; // idb
int prefix_full_length; // idb
int max_width; // idb
const char *prefix; // idb
bool uniform; // idb
bool split; // idb
bool tagged; // idb
bool crown; // idb
const char LC11 = '\0'; // idb
const option long_options[10] =
{
  { "crown-margin", 0, &set_other_indent, 99 },
  { "prefix", 1, &set_other_indent, 112 },
  { "split-only", 0, &set_other_indent, 115 },
  { "tagged-paragraph", 0, &set_other_indent, 116 },
  { "uniform-spacing", 0, &set_other_indent, 117 },
  { "width", 1, &set_other_indent, 119 },
  { "goal", 1, &set_other_indent, 103 },
  { "help", 0, &set_other_indent, -130 },
  { "version", 0, &set_other_indent, -131 },
  { &set_other_indent, 0, &set_other_indent, 0 }
}; // idb
// extern struct _IO_FILE *stdout;
// extern struct _IO_FILE *stdin;
// extern _UNKNOWN program_name; weak
// extern struct _IO_FILE *stderr;
// extern void (*close_stdout)(void); weak
// extern char *optarg;
// extern _UNKNOWN Version; weak
// extern int optind;


//----- (0000000000000000) ----------------------------------------------------
void  set_other_indent(bool same_paragraph)
{
  int v1; // eax

  if ( split )
  {
    other_indent = first_indent;
  }
  else if ( crown )
  {
    v1 = in_column;
    if ( !same_paragraph )
      v1 = first_indent;
    other_indent = v1;
  }
  else if ( tagged )
  {
    if ( !same_paragraph || in_column == first_indent )
    {
      if ( other_indent == first_indent )
        other_indent = first_indent == 0 ? 3 : 0;
    }
    else
    {
      other_indent = in_column;
    }
  }
  else
  {
    other_indent = first_indent;
  }
}

//----- (0000000000000090) ----------------------------------------------------
bool  same_para(int c)
{
  bool result; // al

  result = 0;
  if ( next_prefix_indent == prefix_indent && prefix_full_length + next_prefix_indent <= in_column )
    return c != -1 && c != 10;
  return result;
}

//----- (00000000000000D0) ----------------------------------------------------
COST  base_cost(WORD *this)
{
  COST v1; // r8
  char v2; // al
  char v3; // al

  v1 = 4900LL;
  if ( this > unused_word_type )
  {
    v2 = *((_BYTE *)&this[-1] + 16);
    if ( (v2 & 2) != 0 )
    {
      v1 = (v2 & 8) == 0 ? 364900LL : 2400LL;
    }
    else
    {
      v1 = 3300LL;
      if ( (v2 & 4) == 0 )
      {
        v1 = 4900LL;
        if ( this > &unused_word_type[1] && (*((_BYTE *)&this[-2] + 16) & 8) != 0 )
          v1 = 40000LL / (this[-1].length + 2) + 4900;
      }
    }
  }
  v3 = *((_BYTE *)this + 16);
  if ( (v3 & 1) != 0 )
  {
    v1 -= 1600LL;
    return v1;
  }
  if ( (v3 & 8) == 0 )
    return v1;
  return 22500LL / (this->length + 2) + v1;
}

//----- (0000000000000180) ----------------------------------------------------
COST  line_cost(WORD *next, int len)
{
  COST result; // rax

  if ( word_limit == next )
    return 0LL;
  result = 10 * (goal_width - len) * (long)(10 * (goal_width - len));
  if ( word_limit != next->next_break )
    result += (10 * (len - next->line_length) * (long)(10 * (len - next->line_length))) >> 1;
  return result;
}

//----- (00000000000001D0) ----------------------------------------------------
void  fmt_paragraph()
{
  WORD *v0; // r10
  WORD *v1; // r11
  int v2; // ebx
  int length; // eax
  WORD *v4; // r15
  int v5; // r14d
  int v6; // ebp
  int v7; // r13d
  int v8; // r8d
  WORD *v9; // rcx
  int v10; // r8d
  COST v11; // rax
  int v12; // r8d
  COST v13; // r9
  WORD *v14; // r11
  COST v15; // rax
  WORD *v16; // r10
  WORD *v17; // rdi
  COST v18; // rax
  long v19; // r9
  int saved_length; // [rsp+4h] [rbp-34h]

  v0 = unused_word_type;
  v1 = word_limit;
  v2 = max_width;
  length = word_limit->length;
  v4 = word_limit - 1;
  word_limit->best_cost = 0LL;
  v1->length = v2;
  saved_length = length;
  if ( v4 >= unused_word_type )
  {
    v5 = other_indent;
    v6 = last_line_length;
    v7 = first_indent;
    do
    {
      v8 = v5;
      v9 = v4;
      if ( v4 == v0 )
        v8 = v7;
      v10 = v4->length + v8;
      do
      {
        v11 = line_cost(v9 + 1, v10);
        v15 = v9->best_cost + v11;
        if ( v4 == v16 && v6 > 0 )
          v15 += (10 * (v12 - v6) * (long)(10 * (v12 - v6))) >> 1;
        if ( v15 < v13 )
        {
          v4->next_break = v9;
          v4->line_length = v12;
        }
        if ( v14 == v9 )
          break;
        v10 = v9[-1].space + v9->length + v12;
      }
      while ( v2 > v10 );
      v17 = v4--;
      v18 = base_cost(v17);
      v4[1].best_cost = v19 + v18;
    }
    while ( v4 >= v0 );
  }
  v1->length = saved_length;
}
// 244: variable 'v0' is possibly undefined
// 253: variable 'v13' is possibly undefined
// 255: variable 'v9' is possibly undefined
// 25C: variable 'v12' is possibly undefined
// 263: variable 'v14' is possibly undefined
// 289: variable 'v16' is possibly undefined
// 2BC: variable 'v19' is possibly undefined
// 2D0: variable 'v1' is possibly undefined

//----- (00000000000002F0) ----------------------------------------------------
void  emit_stdin_note()
{
  struct _IO_FILE *v0; // rbp
  char *v1; // rax

  v0 = stdout;
  v1 = dcgettext(0LL, "\nWith no FILE, or when FILE is -, read standard input.\n", 5);
  fputs_unlocked(v1, v0);
}

//----- (0000000000000320) ----------------------------------------------------
void  emit_mandatory_arg_note()
{
  struct _IO_FILE *v0; // rbp
  char *v1; // rax

  v0 = stdout;
  v1 = dcgettext(0LL, "\nMandatory arguments to long options are mandatory for short options too.\n", 5);
  fputs_unlocked(v1, v0);
}

//----- (0000000000000350) ----------------------------------------------------
void  set_prefix(char *p)
{
  bool v1; // zf
  char *v2; // rbx
  int v3; // edx
  char *v4; // rax

  v1 = *p == 32;
  v2 = p;
  prefix_lead_space = 0;
  if ( v1 )
  {
    do
      v3 = 1 - (_DWORD)p + (_DWORD)v2++;
    while ( *v2 == 32 );
    prefix_lead_space = v3;
  }
  prefix = v2;
  prefix_full_length = strlen(v2);
  v4 = &v2[prefix_full_length];
  if ( v4 > v2 )
  {
    do
    {
      if ( *(v4 - 1) != 32 )
        break;
      --v4;
    }
    while ( v4 != v2 );
  }
  *v4 = 0;
  prefix_length = (_DWORD)v4 - (_DWORD)v2;
}

//----- (00000000000003D0) ----------------------------------------------------
int  get_space(FILE *f, int c)
{
  int result; // eax
  int v3; // eax

  for ( result = c; result == 32; result = getc_unlocked(f) )
  {
    v3 = in_column + 1;
LABEL_4:
    in_column = v3;
  }
  if ( result == 9 )
  {
    tabs = 1;
    v3 = 8 * (in_column / 8) + 8;
    goto LABEL_4;
  }
  return result;
}

//----- (0000000000000430) ----------------------------------------------------
int  get_prefix(FILE *f)
{
  int v1; // eax
  int result; // eax
  int v3; // edx
  const char *v4; // rbx
  int v5; // edx

  in_column = 0;
  v1 = getc_unlocked(f);
  result = get_space(f, v1);
  v3 = in_column;
  if ( prefix_length )
  {
    v4 = prefix;
    next_prefix_indent = in_column;
    v5 = *(unsigned char *)prefix;
    if ( (_BYTE)v5 )
    {
      while ( v5 == result )
      {
        ++v4;
        ++in_column;
        result = getc_unlocked(f);
        v5 = *(unsigned char *)v4;
        if ( !(_BYTE)v5 )
          return get_space(f, result);
      }
    }
    else
    {
      return get_space(f, result);
    }
  }
  else
  {
    if ( in_column > prefix_lead_space )
      v3 = prefix_lead_space;
    next_prefix_indent = v3;
  }
  return result;
}

//----- (00000000000004D0) ----------------------------------------------------
void  put_space(int space)
{
  int v1; // edx
  int v2; // ebx
  int v3; // eax
  int v4; // ebp
  signed int v5; // eax
  int v6; // ebp
  int v7; // eax

  v1 = out_column;
  v2 = out_column + space;
  if ( tabs )
  {
    v3 = v2 + 7;
    if ( v2 >= 0 )
      v3 = out_column + space;
    v4 = v3;
    v5 = v3 & 0xFFFFFFF8;
    v6 = v4 >> 3;
    if ( out_column + 1 < v5 && out_column < v5 )
    {
      do
      {
        putchar_unlocked(9);
        v7 = out_column / 8 + 1;
        v1 = 8 * v7;
        out_column = 8 * v7;
      }
      while ( v6 > v7 );
    }
  }
  if ( v2 > v1 )
  {
    do
    {
      putchar_unlocked(32);
      ++out_column;
    }
    while ( out_column < v2 );
  }
}

//----- (0000000000000570) ----------------------------------------------------
void  put_word(WORD *w)
{
  long length; // rbp
  const char *text; // rbx
  const char *v4; // rbp
  int v5; // edi

  length = (unsigned int)w->length;
  text = w->text;
  if ( (_DWORD)length )
  {
    v4 = &text[length];
    do
    {
      v5 = *text++;
      putchar_unlocked(v5);
    }
    while ( v4 != text );
    LODWORD(length) = w->length;
  }
  out_column += length;
}

//----- (00000000000005B0) ----------------------------------------------------
void  put_line(WORD *w, int indent)
{
  WORD *v2; // rbp
  int v3; // ebx
  WORD *v4; // rbx
  WORD *v5; // rdi

  v2 = w;
  out_column = 0;
  put_space(prefix_indent);
  fputs_unlocked(prefix, stdout);
  v3 = indent - (out_column + prefix_length);
  out_column += prefix_length;
  put_space(v3);
  v4 = w->next_break - 1;
  if ( w != v4 )
  {
    do
    {
      v5 = v2++;
      put_word(v5);
      put_space(v2[-1].space);
    }
    while ( v4 != v2 );
  }
  put_word(v2);
  last_line_length = out_column;
  putchar_unlocked(10);
}

//----- (0000000000000650) ----------------------------------------------------
void  put_paragraph(WORD *finish)
{
  WORD *i; // rbx

  put_line(unused_word_type, first_indent);
  for ( i = unused_word_type[0].next_break; finish != i; i = i->next_break )
    put_line(i, other_indent);
}

//----- (00000000000006A0) ----------------------------------------------------
int  copy_rest(FILE *f, int c)
{
  int v2; // ebp
  bool v4; // r12
  int v5; // eax
  int v6; // edx
  int v7; // edi
  const char *v8; // r13
  int result; // eax

  v2 = c;
  out_column = 0;
  v4 = c != -1 && c != 10;
  if ( in_column > next_prefix_indent )
  {
    put_space(next_prefix_indent);
    v5 = out_column;
    v6 = in_column;
    v8 = prefix;
    if ( out_column == in_column )
    {
LABEL_7:
      if ( !v4 )
      {
        if ( c == -1 && next_prefix_indent + prefix_length <= in_column )
          putchar_unlocked(10);
        return v2;
      }
      v7 = v6 - v5;
      goto LABEL_13;
    }
    do
    {
LABEL_6:
      if ( !*v8 )
        break;
      putchar_unlocked(*v8);
      v6 = in_column;
      ++v8;
      v5 = out_column + 1;
      out_column = v5;
    }
    while ( v5 != in_column );
    goto LABEL_7;
  }
  if ( !v4 )
    return v2;
  put_space(next_prefix_indent);
  v5 = out_column;
  v6 = in_column;
  v7 = 0;
  v8 = prefix;
  if ( out_column != in_column )
    goto LABEL_6;
LABEL_13:
  put_space(v7);
  while ( 1 )
  {
    putchar_unlocked(v2);
    result = getc_unlocked(f);
    v2 = result;
    if ( result == 10 )
      break;
    if ( result == -1 )
      return result;
  }
  return v2;
}

//----- (00000000000007E0) ----------------------------------------------------
void  check_punctuation(WORD *w)
{
  const char *text; // r12
  const char *v2; // rbx
  char *v3; // rbp
  int v4; // ebp

  text = w->text;
  v2 = &w->text[w->length - 1];
  v3 = strchr("(['`\"", *w->text);
  *((_BYTE *)w + 16) = *((_BYTE *)w + 16) & 0xFA | (v3 != 0LL) | (*_ctype_b_loc())[*(unsigned char *)v2] & 4;
  if ( text < v2 )
  {
    while ( 1 )
    {
      v4 = *v2;
      if ( !strchr(")]'\"", v4) )
        break;
      if ( text == v2 - 1 )
      {
        v4 = *(v2 - 1);
        break;
      }
      --v2;
    }
  }
  else
  {
    v4 = *v2;
  }
  *((_BYTE *)w + 16) = (2 * (strchr(".?!", v4) != 0LL)) | *((_BYTE *)w + 16) & 0xFD;
}

//----- (00000000000008B0) ----------------------------------------------------
void  flush_paragraph()
{
  WORD *v0; // r12
  WORD *next_break; // rdx
  COST best_cost; // rsi
  WORD *v3; // rbp
  long v4; // rax
  WORD *v5; // rdi
  COST v6; // rcx
  long v7; // rcx
  char *v8; // r12
  int v9; // eax
  const char *text; // rdx
  long v11; // rax
  WORD *v12; // r12
  long v13; // rcx
  WORD *i; // rax

  v0 = word_limit;
  if ( word_limit == unused_word_type )
  {
    fwrite_unlocked(parabuf, 1uLL, wptr - parabuf, stdout);
    wptr = parabuf;
  }
  else
  {
    fmt_paragraph();
    next_break = unused_word_type[0].next_break;
    if ( v0 == unused_word_type[0].next_break )
    {
      v3 = v0;
    }
    else
    {
      best_cost = unused_word_type[0].next_break->best_cost;
      v3 = v0;
      v4 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        v5 = next_break;
        next_break = next_break->next_break;
        v6 = best_cost;
        best_cost = next_break->best_cost;
        v7 = v6 - best_cost;
        if ( v7 < v4 )
        {
          v4 = v7;
          v3 = v5;
        }
        if ( v4 <= 0x7FFFFFFFFFFFFFF6LL )
          v4 += 9LL;
      }
      while ( v0 != next_break );
    }
    put_paragraph(v3);
    v8 = wptr;
    v9 = _memmove_chk(parabuf, v3->text, wptr - v3->text, 5000LL);
    text = v3->text;
    v11 = (int)&v3->text[-v9];
    wptr = &v8[-v11];
    v12 = word_limit;
    v13 = -v11;
    if ( word_limit >= v3 )
    {
      for ( i = v3; ; text = i->text )
      {
        ++i;
        i[-1].text = &text[v13];
        if ( i > v12 )
          break;
      }
    }
    _memmove_chk(unused_word_type, v3, (char *)v12 - (char *)v3 + 40, 40000LL);
    word_limit = (WORD *)((char *)v12 - ((char *)v3 - (char *)unused_word_type));
  }
}
// D498: using guessed type long  _memmove_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000000A10) ----------------------------------------------------
int  get_line(FILE *f, int c)
{
  WORD *v2; // rdx
  int space; // ebp
  char *v5; // rax
  unsigned int v6; // eax
  char v7; // r8
  char *v8; // rdx
  WORD *v9; // rdi
  int v10; // r14d
  signed long v11; // rdx
  int v12; // r14d
  WORD *v13; // rax
  int v14; // edx
  char v15; // cl
  bool v16; // dl

  v2 = word_limit;
  LOBYTE(space) = c;
  do
  {
    while ( 1 )
    {
      v5 = wptr;
      v2->text = wptr;
      while ( 1 )
      {
        if ( v5 == (char *)&out_column )
        {
          set_other_indent(1);
          flush_paragraph();
          v5 = wptr;
        }
        *v5 = space;
        wptr = v5 + 1;
        v6 = getc_unlocked(f);
        space = v6;
        if ( v6 == -1 )
          break;
        v7 = c_isspace(v6);
        v5 = wptr;
        v8 = wptr;
        if ( v7 )
          goto LABEL_8;
      }
      v8 = wptr;
LABEL_8:
      v9 = word_limit;
      v10 = in_column;
      v11 = v8 - word_limit->text;
      word_limit->length = v11;
      v12 = v11 + v10;
      in_column = v12;
      check_punctuation(v9);
      space = get_space(f, space);
      v13 = word_limit;
      v14 = in_column - v12;
      word_limit->space = in_column - v12;
      if ( space == -1 )
        break;
      v15 = *((_BYTE *)v13 + 16);
      if ( (v15 & 2) != 0 )
      {
        v16 = space == 10 || v14 > 1;
        if ( !v16 )
        {
          *((_BYTE *)v13 + 16) = v15 & 0xF7;
          goto LABEL_12;
        }
      }
      else
      {
        v16 = 0;
      }
      *((_BYTE *)v13 + 16) = (8 * v16) | *((_BYTE *)v13 + 16) & 0xF7;
      if ( space == 10 )
        goto LABEL_16;
LABEL_12:
      if ( uniform )
        goto LABEL_16;
      if ( v13 == &unused_word_type[998] )
        goto LABEL_21;
      v2 = v13 + 1;
      word_limit = v13 + 1;
    }
    *((_BYTE *)v13 + 16) |= 8u;
LABEL_16:
    v13->space = ((*((_BYTE *)v13 + 16) & 8) != 0) + 1;
    if ( v13 == &unused_word_type[998] )
    {
LABEL_21:
      set_other_indent(1);
      flush_paragraph();
      v13 = word_limit;
    }
    v2 = v13 + 1;
    word_limit = v13 + 1;
  }
  while ( space != 10 && space != -1 );
  return get_prefix(f);
}
// D4A8: using guessed type long  c_isspace(_QWORD);

//----- (0000000000000BD0) ----------------------------------------------------
bool  get_paragraph(FILE *f)
{
  int prefix; // esi
  bool result; // al
  int line; // esi
  bool v4; // al
  bool v5; // al

  prefix = next_char;
  last_line_length = 0;
  while ( prefix == 10
       || prefix == -1
       || next_prefix_indent < prefix_lead_space
       || next_prefix_indent + prefix_full_length > in_column )
  {
    if ( copy_rest(f, prefix) == -1 )
    {
      next_char = -1;
      return 0;
    }
    putchar_unlocked(10);
    prefix = get_prefix(f);
  }
  prefix_indent = next_prefix_indent;
  first_indent = in_column;
  wptr = parabuf;
  word_limit = unused_word_type;
  line = get_line(f, prefix);
  v4 = same_para(line);
  set_other_indent(v4);
  if ( !split )
  {
    v5 = same_para(line);
    if ( crown )
    {
      if ( v5 )
      {
        do
          line = get_line(f, line);
        while ( same_para(line) && in_column == other_indent );
      }
    }
    else if ( tagged )
    {
      if ( v5 && in_column != first_indent )
      {
        do
          line = get_line(f, line);
        while ( same_para(line) && in_column == other_indent );
      }
    }
    else
    {
      while ( same_para(line) && in_column == other_indent )
        line = get_line(f, line);
    }
  }
  if ( word_limit <= unused_word_type )
    _assert_fail("word < word_limit", "src/fmt.c", 0x270u, "get_paragraph");
  *((_BYTE *)&word_limit[-1] + 16) |= 0xAu;
  result = 1;
  next_char = line;
  return result;
}

//----- (0000000000000DB0) ----------------------------------------------------
bool  fmt(FILE *f, const char *file)
{
  bool paragraph; // r12
  long v3; // r13
  char *v4; // rax
  int v6; // ebp
  const char *v7; // rax

  fadvise(f, 2LL);
  tabs = 0;
  other_indent = 0;
  next_char = get_prefix(f);
  while ( 1 )
  {
    paragraph = get_paragraph(f);
    if ( !paragraph )
      break;
    fmt_paragraph();
    put_paragraph(word_limit);
  }
  if ( ferror_unlocked(f) )
  {
    if ( f == stdin )
      clearerr_unlocked(f);
    else
      rpl_fclose(f);
    v3 = quotearg_n_style_colon(0LL, 3LL, file);
    goto LABEL_8;
  }
  if ( f == stdin )
  {
    clearerr_unlocked(f);
    return 1;
  }
  else
  {
    if ( (unsigned int)rpl_fclose(f) )
    {
      v6 = *_errno_location();
      if ( v6 >= 0 )
      {
        v7 = (const char *)quotearg_n_style_colon(0LL, 3LL, file);
        v3 = (long)v7;
        if ( v6 )
        {
          error(0, v6, "%s", v7);
          return paragraph;
        }
LABEL_8:
        v4 = dcgettext(0LL, "read error", 5);
        error(0, 0, v4, v3);
        return paragraph;
      }
    }
    return 1;
  }
}
// D4B8: using guessed type long  fadvise(_QWORD, _QWORD);
// D4D0: using guessed type long  rpl_fclose(_QWORD);
// D4D8: using guessed type long  quotearg_n_style_colon(_QWORD, _QWORD, _QWORD);

//----- (0000000000000F10) ----------------------------------------------------
void  emit_ancillary_info(const char *program)
{
  emit_ancillary_info_infomap *v1; // rbx
  const char *v2; // rsi
  const char *node; // r13
  char *v4; // rax
  char *v5; // rdi
  char *v6; // rax
  const char *v7; // r12
  char *v8; // rsi
  char *v9; // rax
  char *v10; // rdi
  struct _IO_FILE *v11; // rbp
  char *v12; // rax
  char *v13; // rax
  emit_ancillary_info_infomap infomap[7]; // [rsp+0h] [rbp-A8h] BYREF
  unsigned long v15; // [rsp+78h] [rbp-30h]

  v15 = __readfsqword(0x28u);
  infomap[3].program = "sha256sum";
  v1 = infomap;
  infomap[4].program = "sha384sum";
  infomap[5].program = "sha512sum";
  infomap[6].program = 0LL;
  infomap[6].node = 0LL;
  infomap[0].program = "[";
  infomap[0].node = "test invocation";
  infomap[1].program = "coreutils";
  infomap[1].node = "Multi-call invocation";
  infomap[2].program = "sha224sum";
  infomap[2].node = "sha2 utilities";
  infomap[3].node = "sha2 utilities";
  infomap[4].node = "sha2 utilities";
  infomap[5].node = "sha2 utilities";
  do
  {
    v2 = v1[1].program;
    ++v1;
  }
  while ( v2 && strcmp("fmt", v2) );
  node = v1->node;
  if ( !node )
  {
    v9 = dcgettext(0LL, "\n%s online help: <%s>\n", 5);
    _printf_chk(1LL, v9, "GNU coreutils", "https://www.gnu.org/software/coreutils/");
    v10 = setlocale(5, 0LL);
    if ( !v10 || !strncmp(v10, "en_", 3uLL) )
    {
      v13 = dcgettext(0LL, "Full documentation <%s%s>\n", 5);
      node = "fmt";
      _printf_chk(1LL, v13, "https://www.gnu.org/software/coreutils/", "fmt");
      v7 = " invocation";
      goto LABEL_9;
    }
    node = "fmt";
    goto LABEL_13;
  }
  v4 = dcgettext(0LL, "\n%s online help: <%s>\n", 5);
  _printf_chk(1LL, v4, "GNU coreutils", "https://www.gnu.org/software/coreutils/");
  v5 = setlocale(5, 0LL);
  if ( v5 && strncmp(v5, "en_", 3uLL) )
  {
LABEL_13:
    v11 = stdout;
    v12 = dcgettext(0LL, "Report any translation bugs to <https://translationproject.org/team/>\n", 5);
    fputs_unlocked(v12, v11);
  }
  v6 = dcgettext(0LL, "Full documentation <%s%s>\n", 5);
  _printf_chk(1LL, v6, "https://www.gnu.org/software/coreutils/", "fmt");
  v7 = " invocation";
  if ( node != "fmt" )
    v7 = &LC11;
LABEL_9:
  v8 = dcgettext(0LL, "or available locally via: info '(coreutils) %s%s'\n", 5);
  _printf_chk(1LL, v8, node, v7);
}
// D500: using guessed type long  _printf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000001190) ----------------------------------------------------
void   usage(int status)
{
  long v2; // r12
  char *v3; // rax
  char *v4; // rax
  long v5; // rcx
  struct _IO_FILE *v6; // r12
  char *v7; // rax
  struct _IO_FILE *v8; // r12
  char *v9; // rax
  struct _IO_FILE *v10; // r12
  char *v11; // rax
  struct _IO_FILE *v12; // r12
  char *v13; // rax
  struct _IO_FILE *v14; // r12
  char *v15; // rdi

  v2 = program_name;
  if ( status )
  {
    v3 = dcgettext(0LL, "Try '%s --help' for more information.\n", 5);
    _fprintf_chk(stderr, 1LL, v3, v2);
  }
  else
  {
    v4 = dcgettext(0LL, "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n", 5);
    _printf_chk(1LL, v4, v2, v5);
    v6 = stdout;
    v7 = dcgettext(
           0LL,
           "Reformat each paragraph in the FILE(s), writing to standard output.\n"
           "The option -WIDTH is an abbreviated form of --width=DIGITS.\n",
           5);
    fputs_unlocked(v7, v6);
    emit_stdin_note();
    emit_mandatory_arg_note();
    v8 = stdout;
    v9 = dcgettext(
           0LL,
           "  -c, --crown-margin        preserve indentation of first two lines\n"
           "  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
           "                              reattaching the prefix to reformatted lines\n"
           "  -s, --split-only          split long lines, but do not refill\n",
           5);
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = dcgettext(
            0LL,
            "  -t, --tagged-paragraph    indentation of first line different from second\n"
            "  -u, --uniform-spacing     one space between words, two after sentences\n"
            "  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
            "  -g, --goal=WIDTH          goal width (default of 93% of width)\n",
            5);
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = dcgettext(0LL, "      --help        display this help and exit\n", 5);
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = dcgettext(0LL, "      --version     output version information and exit\n", 5);
    fputs_unlocked(v15, v14);
    emit_ancillary_info(v15);
  }
  exit(status);
}
// 11F6: variable 'v5' is possibly undefined
// D500: using guessed type long  _printf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// D530: using guessed type long  _fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000000CA10) ----------------------------------------------------
int  main(int argc, const char **argv, const char **envp)
{
  int v3; // ebp
  const char **v4; // rbx
  const char *v5; // rax
  int v6; // ecx
  char *v7; // rax
  int v8; // r12d
  char *v9; // rax
  int v10; // eax
  char v11; // r13
  int v12; // r12d
  int v13; // eax
  const char *v14; // r15
  FILE *v15; // rdi
  int v16; // eax
  char *v18; // rax
  char *v19; // rax
  char *v20; // r12
  int *v21; // rax
  const char *v22; // rdx
  char *max_width_option; // [rsp+0h] [rbp-48h]
  unsigned int max_width_optiona; // [rsp+0h] [rbp-48h]
  const char *max_width_optionb; // [rsp+0h] [rbp-48h]
  char *goal_width_option; // [rsp+8h] [rbp-40h]

  v3 = argc;
  v4 = argv;
  set_program_name(*argv);
  setlocale(6, &LC11);
  bindtextdomain("coreutils", "/usr/local/share/locale");
  textdomain("coreutils");
  atexit((void (*)(void))&close_stdout);
  uniform = 0;
  split = 0;
  tagged = 0;
  crown = 0;
  max_width = 75;
  prefix = &LC11;
  prefix_full_length = 0;
  prefix_lead_space = 0;
  prefix_length = 0;
  max_width_option = 0LL;
  if ( argc > 1 )
  {
    v5 = argv[1];
    if ( *v5 == 45 && (unsigned int)(v5[1] - 48) <= 9 )
    {
      v4 = argv + 1;
      v3 = argc - 1;
      max_width_option = (char *)(v5 + 1);
      argv[1] = *argv;
    }
  }
  goal_width_option = 0LL;
  while ( 2 )
  {
    v6 = getopt_long(v3, (char *const *)v4, "0123456789cstuw:p:g:", long_options, 0LL);
    if ( v6 != -1 )
    {
      if ( v6 <= 119 )
      {
        if ( v6 > 98 )
        {
          switch ( v6 )
          {
            case 'c':
              crown = 1;
              continue;
            case 'g':
              goal_width_option = optarg;
              continue;
            case 'p':
              set_prefix(optarg);
              continue;
            case 's':
              split = 1;
              continue;
            case 't':
              tagged = 1;
              continue;
            case 'u':
              uniform = 1;
              continue;
            case 'w':
              max_width_option = optarg;
              continue;
            default:
              goto LABEL_38;
          }
        }
        if ( v6 == -131 )
        {
          version_etc(stdout, "fmt", "GNU coreutils", Version, "Ross Paterson", 0LL);
          exit(0);
        }
        if ( v6 == -130 )
          usage(0);
      }
LABEL_38:
      if ( (unsigned int)(v6 - 48) <= 9 )
      {
        max_width_optiona = v6;
        v19 = dcgettext(
                0LL,
                "invalid option -- %c; -WIDTH is recognized only when it is the first\noption; use -w N instead",
                5);
        error(0, 0, v19, max_width_optiona);
      }
      usage(1);
    }
    break;
  }
  if ( max_width_option )
  {
    v7 = dcgettext(0LL, "invalid width", 5);
    max_width = xdectoumax(max_width_option, 0LL, 2500LL, &LC11, v7, 0LL);
    v8 = max_width;
    if ( goal_width_option )
    {
      v9 = dcgettext(0LL, "invalid width", 5);
      goal_width = xdectoumax(goal_width_option, 0LL, v8, &LC11, v9, 0LL);
      goto LABEL_24;
    }
    goto LABEL_37;
  }
  if ( !goal_width_option )
  {
LABEL_37:
    goal_width = 187 * max_width / 200;
    goto LABEL_24;
  }
  v18 = dcgettext(0LL, "invalid width", 5);
  goal_width = xdectoumax(goal_width_option, 0LL, 75LL, &LC11, v18, 0LL);
  max_width = goal_width + 10;
LABEL_24:
  v10 = optind;
  if ( optind == v3 )
  {
    LOBYTE(v12) = fmt(stdin, "-");
LABEL_34:
    rpl_fclose(stdin);
    return (unsigned char)v12 ^ 1;
  }
  v11 = 0;
  v12 = 1;
  if ( optind < v3 )
  {
    do
    {
      v14 = v4[v10];
      if ( *v14 != 45 || v14[1] )
      {
        v15 = fopen(v4[v10], "r");
        if ( v15 )
        {
          LOBYTE(v16) = fmt(v15, v14);
          v12 &= v16;
        }
        else
        {
          max_width_optionb = (const char *)quotearg_style(4LL, v14);
          v20 = dcgettext(0LL, "cannot open %s for reading", 5);
          v21 = _errno_location();
          v22 = v20;
          v12 = 0;
          error(0, *v21, v22, max_width_optionb);
        }
      }
      else
      {
        v11 = 1;
        LOBYTE(v13) = fmt(stdin, v4[v10]);
        v12 &= v13;
      }
      v10 = optind + 1;
      optind = v10;
    }
    while ( v10 < v3 );
    if ( v11 )
      goto LABEL_34;
  }
  return (unsigned char)v12 ^ 1;
}
// CCF8: variable 'v13' is possibly undefined
// CD39: variable 'v16' is possibly undefined
// D4D0: using guessed type long  rpl_fclose(_QWORD);
// D540: using guessed type long  set_program_name(_QWORD);
// D558: using guessed type void (*close_stdout)(void);
// D580: using guessed type long  version_etc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// D588: using guessed type long  xdectoumax(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// D5A0: using guessed type long  quotearg_style(_QWORD, _QWORD);

// nfuncs=57 queued=23 decompiled=23 lumina nreq=0 worse=0 better=0
// ALL OK, 23 function(s) have been successfully decompiled
